{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83d\udcdc Cicerone","text":""},{"location":"#explore-openapi-schemas-the-pythonic-way","title":"Explore OpenAPI schemas, the Pythonic way","text":"<p>Cicerone lets you parse OpenAPI schemas into Python objects for inspection, traversal, and tooling.</p> <p>The goal of Cicerone is to be fast, minimal, fully typed, and designed for Python developers by Python developers.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Full support: Tested against real-world and example specifications to be 100% compliant.</li> <li>Pydantic-based models: Type-safe object models.</li> <li>Multiple input formats: Load from files, URLs, or in-memory data</li> <li>OpenAPI 3.x support: Works with OpenAPI 3.0 and 3.1 specifications</li> <li>Minimal dependencies: Only relies on Pydantic and yaml. The rest is core Python.</li> <li>Simple API: Intuitive methods for common operations</li> <li>Modern Python: Fully typed and 100% test coverage codebase.</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#pip","title":"pip","text":"<pre><code>pip install cicerone\n</code></pre>"},{"location":"#uv","title":"uv","text":"<pre><code>uv add cicerone\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#parsing-specifications","title":"Parsing Specifications","text":"<p>Load OpenAPI specifications from various sources:</p> <pre><code>from cicerone import parse as cicerone_parse\n\n# From a file (auto-detects YAML/JSON)\nfile_spec = cicerone_parse.parse_spec_from_file(\"openapi.yaml\")\n\n# From a URL\nurl_spec = cicerone_parse.parse_spec_from_url(\"https://api.example.com/openapi.json\")\n\n# From a dictionary\ndict_spec = cicerone_parse.parse_spec_from_dict({\"openapi\": \"3.0.0\", ...})\n\n# From JSON string\njson_spec = cicerone_parse.parse_spec_from_json('{\"openapi\": \"3.0.0\", ...}')\n\n# From YAML string\nyaml_spec = cicerone_parse.parse_spec_from_yaml('openapi: \"3.0.0\"\\n...')\n</code></pre>"},{"location":"#exploring-the-schema","title":"Exploring the schema","text":"<p>Once parsed, traverse the schema:</p> <pre><code>from cicerone import parse as cicerone_parse\n\nspec = cicerone_parse.parse_spec_from_file('tests/fixtures/petstore_openapi3.yaml')\n\nprint(\"OpenAPISpec:\", spec)\nprint(\"Paths:\", spec.paths)\nprint(\"PathItem:\", spec.paths[\"/users\"])\nprint(\"Operation:\", spec.operation_by_operation_id(\"listUsers\"))\nprint(\"Components:\", spec.components)\nprint(\"Schema:\", spec.components.get_schema(\"User\"))\nuser = spec.components.get_schema(\"User\")\nprint(f\"User properties: {list(user.properties.keys())}\")\n\n&gt;&gt;&gt; OpenAPISpec: &lt;OpenAPISpec: 'Test API' v3.0.0, 2 paths, 2 schemas&gt;\n&gt;&gt;&gt; Paths: &lt;Paths: 2 paths, 3 operations [/users, /users/{userId}]&gt;\n&gt;&gt;&gt; PathItem: &lt;PathItem: /users [GET, POST]&gt;\n&gt;&gt;&gt; Operation: &lt;Operation: GET /users, id=listUsers, 'List all users', tags=['users']&gt;\n&gt;&gt;&gt; Components: &lt;Components: 2 schemas [User, Error]&gt;\n&gt;&gt;&gt; Schema: &lt;Schema: type=object, 5 properties, required=['id', 'username', 'email']&gt;\n&gt;&gt;&gt; User properties: ['id', 'username', 'email', 'age', 'roles']\n</code></pre>"},{"location":"#resolving-references","title":"Resolving References","text":"<p>Resolve <code>$ref</code> references to their typed objects:</p> <pre><code>from cicerone import parse as cicerone_parse\n\nspec = cicerone_parse.parse_spec_from_file('tests/fixtures/petstore_openapi3.yaml')\n\n# Resolve a reference to get a typed Schema object\n# Note: pass follow_nested=True to recursively resolve all nested $refs\nuser_schema = spec.resolve_reference('#/components/schemas/User', follow_nested=True)\nprint(f\"User schema type: {user_schema.type}\")\nprint(f\"Required fields: {user_schema.required}\")\n\n&gt;&gt;&gt; User schema type: object\n&gt;&gt;&gt; Required fields: ['id', 'username', 'email']\n</code></pre>"},{"location":"#accessing-raw-data","title":"Accessing Raw Data","text":"<p>Access the original specification dictionary when needed:</p> <pre><code># Version information\nprint(f\"API Version: {spec.version}\")\nprint(f\"Major: {spec.version.major}, Minor: {spec.version.minor}\")\n\n# Raw spec data\nprint(f\"Title: {spec.raw['info']['title']}\")\n</code></pre>"},{"location":"CHANGELOG/","title":"Change log","text":""},{"location":"CHANGELOG/#020","title":"0.2.0","text":"<ul> <li>Added the OpenAPISpec object model for traversing OpenAPI specifications to cover 100% of the OpenAPI specification.</li> <li>Added parser functions for loading specs from files, URLs, JSON, YAML, and dictionaries</li> <li>Added support for OpenAPI 3.0.x and higher specifications.</li> <li>All OpenAPI objects represented as Pydantic-based models for type-safe schema exploration</li> <li>Added comprehensive tests for parsing real-world OpenAPI schemas from APIs.guru openapi-directory</li> <li>Added comprehensive test suite for OpenAPI example schemas covering all supported features</li> <li>Added reference navigation API for resolving $ref references in OpenAPI specifications</li> <li>New <code>Reference</code> model to represent OpenAPI Reference Objects</li> <li>New <code>ReferenceResolver</code> class for navigating and resolving references</li> <li><code>resolve_reference()</code> method returns typed Pydantic objects (Schema, Response, etc.) not raw dicts</li> <li>Added <code>get_all_references()</code> method to OpenAPISpec to find all references in the specification</li> <li>Support for local references (e.g., <code>#/components/schemas/User</code>)</li> <li>Full support for JSON Pointer syntax in references</li> </ul>"},{"location":"CHANGELOG/#010","title":"0.1.0","text":"<ul> <li>Initial version</li> </ul>"},{"location":"examples/","title":"\ud83e\ude84 Client example","text":"<p>Let's build an API Client using cicerone.</p> <p>Our GitHub has a bunch of schemas that are proven to work with cicerone, so let's use one of those!</p>"},{"location":"examples/#generate-the-client","title":"Generate the client","text":"<p>In your project's root directory:</p> <pre><code>cicerone generate -u https://raw.githubusercontent.com/phalt/cicerone/main/example_openapi_specs/best.json -o my_client/\n</code></pre> <p>Note</p> <p>The example above uses one of our test schemas, and will work if you copy/paste it!</p> <p>The <code>-u</code> parameter expects a URL, you can provide a path to a file with <code>-f</code> instead if you download the file.</p> <p>The <code>-o</code> parameter is the output directory of the generated client.</p> <p>Run it now and you will see this output:</p> <pre><code>my_client/\n    __init__.py\n    client.py\n    config.py\n    http.py\n    MANIFEST\n    schemas.py\n</code></pre> <p>Let's go over each file and talk about what it does.</p>"},{"location":"examples/#client","title":"Client","text":""},{"location":"examples/#get-functions","title":"GET functions","text":"<p>The <code>client.py</code> file provides all the API functions from the OpenAPI schema. Functions are a combination of the path and the HTTP method for those paths. So, a path with two HTTP methods will be turned into two python functions.</p> my_client/client.py<pre><code>from my_client import http, schemas\n\n\ndef simple_request_simple_request_get() -&gt; schemas.SimpleResponse:\n    \"\"\"Simple Request\"\"\"\n\n    response = http.get(url=\"/simple-request\")\n    return http.handle_response(simple_request_simple_request_get, response)\n\n...\n</code></pre> <p>We can see one of the functions here, <code>simple_request_simple_request_get</code>, is for a straight-forward HTTP GET request without any input arguments, and it returns a schema object.</p> <p>Here is how you might use it:</p> <pre><code>from my_client import client\n\nclient.simple_request_simple_request_get()\n&gt;&gt;&gt; SimpleResponse(name='Hello, cicerone')\n</code></pre>"},{"location":"examples/#post-and-put-functions","title":"POST and PUT functions","text":"<p>A more complex example is shown just below. </p> <p>This is for an HTTP POST method, and it requires an input property called <code>data</code> that is an instance of a schema, and returns one of many potential responses. If the endpoint has url parameters or query parameters, they will appear as input arguments to the function alongside the <code>data</code> argument.</p> <pre><code>def request_data_request_data_post(\n    data: schemas.RequestDataRequest\n) -&gt; schemas.RequestDataResponse | schemas.HTTPValidationError:\n    \"\"\"Request Data\"\"\"\n\n    response = http.post(url=\"/request-data\", data=data.model_dump())\n    return http.handle_response(request_data_request_data_post, response)\n</code></pre> <p>Here is how you might use it:</p> <pre><code>from my_client import client, schemas\n\ndata = schemas.RequestDataRequest(my_input=\"Hello, world\")\nresponse = client.request_data_request_data_post(data=data)\n&gt;&gt;&gt; RequestDataResponse(your_input='Hello, world')\n</code></pre> <p>cicerone also supports the major HTTP methods PUT and DELETE in the same way.</p>"},{"location":"examples/#url-and-query-parameters","title":"URL and Query parameters","text":"<p>If your endpoint takes path parameters (aka URL parameters) then cicerone will turn them into parameters in the function:</p> <pre><code>from my_client import client\n\nclient.parameter_request_simple_request(your_input=\"gibberish\")\n&gt;&gt;&gt; ParameterResponse(your_input='gibberish')\n</code></pre> <p>Query parameters will also be generated the same way. See this example for a function that takes a required query parameter.</p> <p>Note that, optional parameters that are not passed will be omitted when the URL is generated by cicerone.</p>"},{"location":"examples/#handling-responses","title":"Handling responses","text":"<p>Because we're using Pydantic to manage the input data, we get a strongly-typed response object. This works beautifully with the new structural pattern matching feature in Python 3.10 and up:</p> <pre><code>response = client.request_data_request_data_post(data=data)\n\n# Handle responses elegantly\nmatch response:\n    case schemas.RequestDataResponse():\n        # Handle valid response\n        ...\n    case schemas.ValidationError():\n        # Handle validation error\n        ...\n</code></pre>"},{"location":"examples/#api-exceptions","title":"API Exceptions","text":"<p>cicerone keeps a mapping of the paths and their potential response codes. When it gets a response code that fits into the map, it generates the pydantic object associated to it.</p> <p>If the HTTP response code is an unintended one, it will not match a return type. In this case, the function will raise an <code>http.APIException</code>.</p> <pre><code>from my_client import client, http\ntry:\n    good_response = my_client.get_my_thing()\nexcept http.APIException as e:\n    # The API got a response code we didn't expect\n    print(e.response.status_code)\n</code></pre> <p>The <code>response</code> object will be attached to this exception class for your own debugging.</p>"},{"location":"examples/#schemas","title":"Schemas","text":"<p>The <code>schemas.py</code> file has all the possible schemas, request and response, and even Enums, for the API. These are taken from OpenAPI's  schemas objects and turned into Python classes. They are all subclassed from pydantic's <code>BaseModel</code>.</p> <p>Here are a few examples:</p> my_client/schemas.py<pre><code>import pydantic\nfrom enum import Enum\n\n\nclass ParameterResponse(pydantic.BaseModel):\n    your_input: str\n\nclass RequestDataRequest(pydantic.BaseModel):\n    my_input: str\n\nclass RequestDataResponse(pydantic.BaseModel):\n    my_input: str\n\n# Enums subclass str so they serialize to JSON nicely\nclass ExampleEnum(str, Enum):\n    ONE = \"ONE\"\n    TWO = \"TWO\"\n</code></pre>"},{"location":"examples/#configuration","title":"Configuration","text":"<p>One of the problems with auto-generated clients is that you often need to configure them, and if you try and regenerate the client at some point in the future then your configuration gets wiped clean and you have to do it all over again.</p> <p>cicerone solves this problem by providing an entry point for configuration that will never be overwritten - <code>config.py</code>.</p> <p>When you first generate the project, you will see a file called <code>config.py</code> and it will offer configuration functions a bit like this:</p> <pre><code>\"\"\"\nThis file will never be updated on subsequent cicerone runs.\nUse it as a space to store configuration and constants.\n\nDO NOT CHANGE THE FUNCTION NAMES\n\"\"\"\n\n\ndef api_base_url() -&gt; str:\n    \"\"\"\n    Modify this function to provide the current api_base_url.\n    \"\"\"\n    return \"http://localhost\"\n</code></pre> <p>Subsequent runs of the <code>generate</code> command with <code>--regen t</code> will not change this file if it exists, so you are free to modify the defaults to suit your needs. </p> <p>For example, if you need to source the base url of your API for different configurations, you can modify the <code>api_base_url</code> function like this:</p> <pre><code>from my_project import my_config\n\ndef api_base_url() -&gt; str:\n    \"\"\"\n    Modify this function to provide the current api_base_url.\n    \"\"\"\n    if my_config.debug:\n        return \"http://localhost:8000\"\n    elif my_config.production:\n        return \"http://my-production-url.com\"\n</code></pre> <p>Just keep the function names the same and you're good to go.</p>"},{"location":"examples/#authentication","title":"Authentication","text":"<p>If your OpenAPI spec provides security information for the following authentication methods:</p> <ul> <li>HTTP Bearer</li> <li>HTTP Basic</li> </ul> <p>Then cicerone will provide you information on the environment variables you need to set to make this work during the generation. For example:</p> <pre><code>Please see my_client/config.py to set authentication variables\n</code></pre> <p>The <code>config.py</code> file will have entry points for you to configure, for example, HTTP Bearer authentication will need the <code>get_bearer_token</code> function to be updated, something like this:</p> <pre><code>def get_bearer_token() -&gt; str:\n    \"\"\"\n    HTTP Bearer authentication.\n    Used by many authentication methods - token, jwt, etc.\n    Does not require the \"Bearer\" content, just the key as a string.\n    \"\"\"\n    from os import environ\n    return environ.get(\"MY_AUTHENTICATION_TOKEN\")\n</code></pre>"},{"location":"examples/#additional-headers","title":"Additional headers","text":"<p>If you want to pass specific headers with all requests made by the client, you can configure the <code>additional_headers</code> function in <code>config.py</code> to do this.</p> <pre><code>def additional_headers() -&gt; dict:\n    \"\"\"\n    Modify this function ot provide additional headers to all\n    HTTP requests made by this client.\n    \"\"\"\n    return {}\n</code></pre> <p>Please note that if you are using this with authentication headers, then authentication headers will overwrite these defaults if they keys match.</p>"},{"location":"install/","title":"\ud83c\udfd7\ufe0f Install","text":""},{"location":"install/#with-pip","title":"With pip","text":"<pre><code>pip install cicerone\n</code></pre>"},{"location":"install/#with-uv","title":"With uv","text":"<pre><code>uv add cicerone\n</code></pre>"},{"location":"references/","title":"Working with References","text":"<p>OpenAPI specifications use references (<code>$ref</code>) to avoid duplication and keep schemas manageable. Cicerone provides a comprehensive API for navigating and resolving these references.</p>"},{"location":"references/#understanding-references-in-openapi","title":"Understanding References in OpenAPI","text":"<p>A reference in OpenAPI uses the <code>$ref</code> keyword to point to another part of the specification. References follow the JSON Reference specification (RFC 6901) and use JSON Pointer syntax.</p>"},{"location":"references/#reference-types","title":"Reference Types","text":"<p>Cicerone supports several types of references:</p> <ol> <li> <p>Local references - Point to other parts of the same document    <pre><code>$ref: '#/components/schemas/User'\n</code></pre></p> </li> <li> <p>External references - Point to other files (coming in future versions)    <pre><code>$ref: './models/user.yaml#/User'\n</code></pre></p> </li> </ol>"},{"location":"references/#reference-locations","title":"Reference Locations","text":"<p>References can appear in various places in an OpenAPI specification:</p> <ul> <li>Schema objects - Most common, referencing reusable schemas</li> <li>Response objects - Referencing reusable responses</li> <li>Parameter objects - Referencing reusable parameters</li> <li>Request body objects - Referencing reusable request bodies</li> <li>And more - Anywhere the spec allows a Reference Object</li> </ul>"},{"location":"references/#basic-reference-navigation","title":"Basic Reference Navigation","text":""},{"location":"references/#resolving-a-reference","title":"Resolving a Reference","text":"<p>The most common operation is resolving a reference to get its target object as a typed Pydantic model:</p> <pre><code>from cicerone import parse as cicerone_parse\nfrom cicerone.spec import Schema\n\n# Load your OpenAPI spec\nspec = cicerone_parse.parse_spec_from_file('openapi.yaml')\n\n# Resolve a reference to a schema - returns a Schema object, not a dict\nuser_schema = spec.resolve_reference('#/components/schemas/User')\nprint(f\"Type: {type(user_schema)}\")  # &lt;class 'cicerone.spec.schema.Schema'&gt;\nprint(f\"User schema type: {user_schema.type}\")\nprint(f\"User properties: {list(user_schema.properties.keys())}\")\n</code></pre> <p>Example with a sample schema:</p> <pre><code>components:\n  schemas:\n    User:\n      type: object\n      required:\n        - id\n        - username\n        - email\n      properties:\n        id:\n          type: string\n        username:\n          type: string\n        email:\n          type: string\n          format: email\n</code></pre> <pre><code># Resolves to a typed Schema object\nuser_schema = spec.resolve_reference('#/components/schemas/User')\nassert isinstance(user_schema, Schema)\n# Access properties directly as attributes\nprint(user_schema.type)  # 'object'\nprint(user_schema.required)  # ['id', 'username', 'email']\nprint(user_schema.properties['email'].format)  # 'email'\n</code></pre>"},{"location":"references/#finding-all-references","title":"Finding All References","text":"<p>You can discover all references in your specification as a dictionary:</p> <pre><code># Get all references as a dict mapping $ref strings to Reference objects\nall_refs = spec.get_all_references()\n\n# Access specific references by their $ref string\nuser_ref = all_refs.get('#/components/schemas/User')\nif user_ref:\n    print(f\"Found reference: {user_ref.ref}\")\n\n# Filter by type\nlocal_refs = {k: v for k, v in all_refs.items() if v.is_local}\nexternal_refs = {k: v for k, v in all_refs.items() if v.is_external}\n\nprint(f\"Found {len(all_refs)} total references\")\nprint(f\"Local: {len(local_refs)}, External: {len(external_refs)}\")\n\n# List all schema references\nschema_refs = {k: v for k, v in all_refs.items() if '/schemas/' in k}\nfor ref_str, ref_obj in schema_refs.items():\n    print(f\"  - {ref_str}\")\n</code></pre>"},{"location":"references/#working-with-the-reference-model","title":"Working with the Reference Model","text":"<p>The <code>Reference</code> class provides properties to inspect and work with reference objects:</p> <pre><code>from cicerone.references import Reference\nfrom cicerone.spec import Schema\n\n# Create a reference object\nref = Reference(ref='#/components/schemas/Pet')\n\n# Check reference type\nprint(f\"Is local: {ref.is_local}\")  # True\nprint(f\"Is external: {ref.is_external}\")  # False\n\n# Get the JSON Pointer\nprint(f\"Pointer: {ref.pointer}\")  # /components/schemas/Pet\n\n# Get pointer components\nprint(f\"Parts: {ref.pointer_parts}\")  # ['components', 'schemas', 'Pet']\n\n# Resolve the reference to get the actual Schema object\npet_schema = spec.resolve_reference(ref)\nassert isinstance(pet_schema, Schema)\nprint(f\"Pet schema type: {pet_schema.type}\")\n</code></pre>"},{"location":"references/#oas-31-summary-and-description","title":"OAS 3.1 Summary and Description","text":"<p>In OpenAPI 3.1, Reference Objects can have <code>summary</code> and <code>description</code> fields:</p> <pre><code>from cicerone.references import Reference\n\nref = Reference(ref='#/components/schemas/User',\n    summary='User schema',\n    description='Represents a user in the system'\n)\n\nprint(f\"Reference: {ref.ref}\")\nprint(f\"Summary: {ref.summary}\")\nprint(f\"Description: {ref.description}\")\n</code></pre>"},{"location":"references/#advanced-reference-operations","title":"Advanced Reference Operations","text":""},{"location":"references/#nested-references","title":"Nested References","text":"<p>Cicerone can automatically follow nested references:</p> <pre><code>components:\n  schemas:\n    UserList:\n      type: array\n      items:\n        $ref: '#/components/schemas/User'\n    User:\n      $ref: '#/components/schemas/Person'\n    Person:\n      type: object\n      properties:\n        name:\n          type: string\n</code></pre> <pre><code># By default, follows nested references\nperson = spec.resolve_reference('#/components/schemas/User')\n# Returns the Person schema (fully resolved)\n\n# Or stop at the first level\nuser_ref = spec.resolve_reference('#/components/schemas/User', follow_nested=False)\n</code></pre>"},{"location":"references/#circular-reference-detection","title":"Circular Reference Detection","text":"<p>Some schemas have circular references (e.g., tree structures):</p> <pre><code>components:\n  schemas:\n    Node:\n      type: object\n      properties:\n        value:\n          type: string\n        children:\n          type: array\n          items:\n            $ref: '#/components/schemas/Node'  # Circular!\n</code></pre> <p>Cicerone detects and handles circular references:</p> <pre><code>from cicerone.references import ReferenceResolver\n\n# Check if a reference is circular\nresolver = ReferenceResolver(spec)\nis_circular = resolver.is_circular_reference('#/components/schemas/Node')\nprint(f\"Is circular: {is_circular}\")\n\n# When resolving with follow_nested=True, circular references are handled\n# by stopping recursion - the circular reference remains as a Reference object\n# pointing back to create a linked-list style structure\nnode = spec.resolve_reference('#/components/schemas/Node', follow_nested=True)\nprint(\"Node schema resolved successfully with circular handling\")\n</code></pre>"},{"location":"references/#array-index-references","title":"Array Index References","text":"<p>You can use array indices in reference paths:</p> <pre><code>tags:\n  - name: users\n    description: User operations\n  - name: posts\n    description: Post operations\n</code></pre> <pre><code># Reference by array index\nposts_tag = spec.resolve_reference('#/tags/1')\nprint(f\"Tag name: {posts_tag['name']}\")  # 'posts'\n</code></pre>"},{"location":"references/#reference-resolution-rules","title":"Reference Resolution Rules","text":""},{"location":"references/#oas-30-vs-31-differences","title":"OAS 3.0 vs 3.1 Differences","text":"<p>The behavior of references differs slightly between OpenAPI versions:</p> <p>OpenAPI 3.0: - Reference Objects can only contain <code>$ref</code> - Adjacent keywords are ignored - References fully replace the object</p> <p>OpenAPI 3.1: - Reference Objects can have <code>summary</code> and <code>description</code> - These fields override the target's values - In Schema Objects, <code>$ref</code> can coexist with other keywords (acts like <code>allOf</code>)</p> <p>Cicerone handles both versions correctly, preserving the raw specification data.</p>"},{"location":"references/#api-reference","title":"API Reference","text":""},{"location":"references/#openapispec-methods","title":"OpenAPISpec Methods","text":""},{"location":"references/#resolve_referenceref-follow_nestedtrue","title":"<code>resolve_reference(ref, follow_nested=True)</code>","text":"<p>Resolve a reference to its target object as a typed Pydantic model.</p> <p>Parameters: - <code>ref</code> (str or Reference): Reference to resolve - <code>follow_nested</code> (bool): Whether to recursively resolve nested references</p> <p>Returns: Typed Pydantic model (Schema, Response, Parameter, etc.) when the reference points to a recognized component type. Otherwise returns raw data.</p> <p>Raises: - <code>ValueError</code>: If reference cannot be resolved - <code>RecursionError</code>: If circular reference detected</p>"},{"location":"references/#get_all_references","title":"<code>get_all_references()</code>","text":"<p>Get all references in the specification.</p> <p>Returns: Dictionary mapping $ref strings to Reference objects</p> <p>Example: <pre><code>all_refs = spec.get_all_references()\nuser_ref = all_refs.get('#/components/schemas/User')\nlocal_refs = {k: v for k, v in all_refs.items() if v.is_local}\n</code></pre></p>"},{"location":"references/#is_circular_referenceref","title":"<code>is_circular_reference(ref)</code>","text":"<p>Check if a reference creates a circular dependency.</p> <p>Parameters: - <code>ref</code> (str or Reference): Reference to check</p> <p>Returns: bool - True if circular</p>"},{"location":"references/#reference-class","title":"Reference Class","text":""},{"location":"references/#properties","title":"Properties","text":"<ul> <li><code>ref</code> (str): The reference string</li> <li><code>summary</code> (str | None): Summary (OAS 3.1+)</li> <li><code>description</code> (str | None): Description (OAS 3.1+)</li> <li><code>is_local</code> (bool): True if local reference (#...)</li> <li><code>is_external</code> (bool): True if external reference</li> <li><code>pointer</code> (str): JSON Pointer part (/components/schemas/User)</li> <li><code>document</code> (str): Document part (for external refs)</li> <li><code>pointer_parts</code> (list[str]): Pointer split into components</li> </ul>"},{"location":"references/#methods","title":"Methods","text":"<ul> <li><code>from_dict(data)</code>: Create from dictionary</li> <li><code>is_reference(data)</code>: Check if data contains $ref</li> </ul>"},{"location":"references/#best-practices","title":"Best Practices","text":"<ol> <li>Check for references before accessing: Use <code>Reference.is_reference()</code> to check if an object is a reference</li> <li>Handle circular references gracefully: Use <code>is_circular_reference()</code> before full resolution</li> <li>Cache resolved references: If resolving the same reference multiple times, cache the results</li> <li>Validate references: Check that all references in your spec can be resolved</li> </ol>"},{"location":"references/#limitations","title":"Limitations","text":"<p>Current limitations (to be addressed in future versions):</p> <ul> <li>External references (file paths, URLs) are not yet supported</li> <li><code>operationRef</code> in Link Objects is not yet implemented</li> <li><code>mapping</code> in Discriminator Objects is not yet implemented</li> <li>Dynamic references (<code>$dynamicRef</code>) from JSON Schema 2020-12 / OAS 3.1 are not yet supported</li> </ul>"},{"location":"references/#see-also","title":"See Also","text":"<ul> <li>OpenAPI Reference Object Specification</li> <li>JSON Pointer RFC 6901</li> <li>JSON Reference Draft</li> </ul>"}]}