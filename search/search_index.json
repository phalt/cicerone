{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83d\udcdc Cicerone","text":""},{"location":"#turn-openapi-schemas-into-pydantic-models","title":"Turn OpenAPI schemas into Pydantic models","text":"<p>Cicerone parses OpenAPI schemas into Pydantic models for introspection and traversal.</p> <p>Cicerone is the fastest, most minimal, fully typed, pythonic library for dealing with OpenAPI schemas.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Full support: Tested against 4000+ real schemas from APIs.guru OpenAPI Directory to ensure broad compatibility.</li> <li>Pydantic-based models: Type-safe object models.</li> <li>Multiple input formats: Load from files, URLs, or in-memory data in various formats.</li> <li>OpenAPI 3.x support: Works with OpenAPI 3.0 and 3.1 specifications</li> <li>Minimal dependencies: Only relies on Pydantic and pyyaml. The rest is core Python.</li> <li>Simple API: Intuitive methods for common operations.</li> <li>Modern Python: Fully typed and 100% test coverage codebase.</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#pip","title":"pip","text":"<pre><code>pip install cicerone\n</code></pre>"},{"location":"#uv","title":"uv","text":"<pre><code>uv add cicerone\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#parsing-specifications","title":"Parsing Specifications","text":"<pre><code>from cicerone import parse as cicerone_parse\n\n# From a file\nfile_spec = cicerone_parse.parse_spec_from_file(\"openapi.yaml\")\n\n# From a URL\nurl_spec = cicerone_parse.parse_spec_from_url(\"https://api.example.com/openapi.json\")\n\n# From a dictionary\ndict_spec = cicerone_parse.parse_spec_from_dict({\"openapi\": \"3.0.0\", ...})\n\n# From JSON string\njson_spec = cicerone_parse.parse_spec_from_json('{\"openapi\": \"3.0.0\", ...}')\n\n# From YAML string\nyaml_spec = cicerone_parse.parse_spec_from_yaml('openapi: \"3.0.0\"\\n...')\n</code></pre>"},{"location":"#exploring-the-schema","title":"Exploring the schema","text":"<pre><code>from cicerone import parse as cicerone_parse\n\nspec = cicerone_parse.parse_spec_from_file('tests/fixtures/petstore_openapi3.yaml')\n\nprint(\"OpenAPISpec:\", spec)\n&gt;&gt;&gt; OpenAPISpec: &lt;OpenAPISpec: 'Test API' v3.0.0, 2 paths, 2 schemas&gt;\n\nprint(\"Paths:\", spec.paths)\n&gt;&gt;&gt; Paths: &lt;Paths: 2 paths, 3 operations [/users, /users/{userId}]&gt;\n\nprint(\"PathItem:\", spec.paths[\"/users\"])\n&gt;&gt;&gt; PathItem: &lt;PathItem: /users [GET, POST]&gt;\n\nprint(\"Operation:\", spec.operation_by_operation_id(\"listUsers\"))\n&gt;&gt;&gt; Operation: &lt;Operation: GET /users, id=listUsers, 'List all users', tags=['users']&gt;\n\nprint(\"Components:\", spec.components)\n&gt;&gt;&gt; Components: &lt;Components: 2 schemas [User, Error]&gt;\n\nprint(\"Schema:\", spec.components.get_schema(\"User\"))\n&gt;&gt;&gt; Schema: &lt;Schema: type=object, 5 properties, required=['id', 'username', 'email']&gt;\n\nuser = spec.components.get_schema(\"User\")\nprint(f\"User properties: {list(user.properties.keys())}\")\n&gt;&gt;&gt; User properties: ['id', 'username', 'email', 'age', 'roles']\n</code></pre>"},{"location":"#resolving-references","title":"Resolving References","text":"<p>Resolve <code>$ref</code> references to their typed objects:</p> <pre><code>from cicerone import parse as cicerone_parse\n\nspec = cicerone_parse.parse_spec_from_file('tests/fixtures/petstore_openapi3.yaml')\n\n# Resolve a reference to get a typed Schema object\n# follow_nested=True will recursively resolve all nested $refs\nuser_schema = spec.resolve_reference('#/components/schemas/User', follow_nested=True)\nprint(f\"User schema type: {user_schema.type}\")\n&gt;&gt;&gt; User schema type: object\nprint(f\"Required fields: {user_schema.required}\")\n&gt;&gt;&gt; Required fields: ['id', 'username', 'email']\n</code></pre>"},{"location":"CHANGELOG/","title":"Change log","text":""},{"location":"CHANGELOG/#020","title":"0.2.0","text":"<ul> <li>Added the OpenAPISpec object model. Traverse OpenAPI specifications as pydantic models - covers 100% of the OpenAPI specification.</li> <li>Added parser functions for loading specs from files, URLs, JSON, YAML, and dictionaries.</li> <li>Added support for OpenAPI 3.0.x and higher specifications.</li> <li>Added comprehensive tests for parsing real-world OpenAPI schemas.</li> <li>Added comprehensive test suite for OpenAPI example schemas.</li> <li>Added reference navigation API for resolving $ref references in OpenAPI specifications</li> <li>Full support for JSON Pointer syntax in references</li> </ul>"},{"location":"CHANGELOG/#010","title":"0.1.0","text":"<ul> <li>Initial version</li> </ul>"},{"location":"compatibility/","title":"Compatibility &amp; Testing","text":"<p>Cicerone is rigorously tested to ensure it works with real-world OpenAPI schemas. </p> <p>We use multiple layers of testing to validate compatibility across a wide range of specifications.</p>"},{"location":"compatibility/#testing-strategy","title":"Testing Strategy","text":"<p>Our testing approach combines unit tests, integration tests, and large-scale compatibility testing to ensure Cicerone works reliably with any OpenAPI schema you throw at it.</p>"},{"location":"compatibility/#unit-tests","title":"Unit Tests","text":"<p>The test suite includes comprehensive unit tests for individual components:</p> <ul> <li>Parser functions: Testing all input formats (files, URLs, dicts, JSON, YAML)</li> <li>Schema models: Validating Pydantic model behavior and field handling</li> <li>References: Testing <code>$ref</code> resolution and circular reference handling</li> <li>Components: Verifying proper parsing of schemas, parameters, responses, etc.</li> <li>OpenAPI features: Testing callbacks, webhooks, security schemes, and extensions</li> </ul> <p>These tests ensure that each piece of Cicerone works correctly in isolation.</p>"},{"location":"compatibility/#real-world-schema-tests","title":"Real-World Schema Tests","text":"<p>We maintain a collection of real-world OpenAPI schemas from popular APIs to test against:</p> <ul> <li>Ably - Event streaming API (OpenAPI 3.0.1)</li> <li>Twilio - Communications API (OpenAPI 3.0.1)</li> <li>1Password - Security and secrets management (OpenAPI 3.0.0)</li> <li>Google - Cloud services APIs (OpenAPI 3.0.0)</li> <li>SpaceTraders - Game API (OpenAPI 3.0.0)</li> <li>Adyen - Payment platform with OpenAPI 3.1 features (OpenAPI 3.1.0)</li> </ul> <p>These schemas cover a wide range of features and edge cases found in production APIs.</p>"},{"location":"compatibility/#openapi-directory-compatibility-testing","title":"OpenAPI Directory Compatibility Testing","text":"<p>To ensure maximum compatibility, Cicerone is tested against the entire APIs.guru OpenAPI Directory - a massive collection of 4000+ real-world OpenAPI schemas from hundreds of different APIs.</p> <p>This testing happens automatically:</p> <ul> <li>Weekly CI runs: Every Monday, GitHub Actions runs the test suite against all schemas</li> <li>Manual testing: Developers can run compatibility tests locally</li> <li>Continuous monitoring: The test results are tracked to catch regressions</li> </ul>"},{"location":"compatibility/#running-compatibility-tests","title":"Running Compatibility Tests","text":"<p>You can run the compatibility tests yourself:</p> <pre><code># Test against all schemas (takes several minutes)\nmake test-openapi-directory\n\n# Test a limited subset for quick feedback\npython3 test_openapi_directory.py --limit 100\n\n# Stop on first failure for debugging\npython3 test_openapi_directory.py -x\n\n# Keep the cloned repository for inspection\npython3 test_openapi_directory.py --keep-repo\n</code></pre>"},{"location":"compatibility/#current-results","title":"Current Results","text":"<p>As of the latest test run, Cicerone successfully parses 98.72% of schemas in the OpenAPI Directory:</p> <pre><code>================================================================================\nSUMMARY\n================================================================================\nTotal schemas tested: 4138\nSuccessful: 4085\nFailed: 53\nSuccess rate: 98.72%\n\n53 schemas failed to parse:\n  - APIs/akeneo.com/1.0.0/swagger.yaml\n  - APIs/apidapp.com/2019-02-14T164701Z/openapi.yaml\n  - APIs/atlassian.com/jira/1001.0.0-SNAPSHOT/openapi.yaml\n  - APIs/azure.com/cognitiveservices-LUIS-Authoring/2.0/swagger.yaml\n  - APIs/azure.com/cognitiveservices-LUIS-Authoring/3.0-preview/swagger.yaml\n  - APIs/azure.com/cognitiveservices-LUIS-Programmatic/v2.0/swagger.yaml\n  - APIs/azure.com/network-applicationGateway/2015-06-15/swagger.yaml\n  - APIs/azure.com/network-applicationGateway/2016-09-01/swagger.yaml\n  - APIs/azure.com/network-applicationGateway/2016-12-01/swagger.yaml\n  - APIs/azure.com/network-applicationGateway/2017-03-01/swagger.yaml\n  ... and 43 more\n</code></pre> <p>Note: A large majority of these failures are due to malformed content in the schemas file itself.</p>"},{"location":"compatibility/#openapi-version-support","title":"OpenAPI Version Support","text":"<p>Cicerone fully supports both major OpenAPI 3.x versions:</p>"},{"location":"compatibility/#openapi-30x","title":"OpenAPI 3.0.x","text":"<p>Full support for all OpenAPI 3.0 features:</p> <ul> <li>\u2705 Path operations (GET, POST, PUT, DELETE, etc.)</li> <li>\u2705 Request and response schemas</li> <li>\u2705 Parameters (path, query, header, cookie)</li> <li>\u2705 Components (schemas, parameters, responses, examples, etc.)</li> <li>\u2705 Security schemes (apiKey, http, oauth2, openIdConnect)</li> <li>\u2705 Callbacks</li> <li>\u2705 Server variables</li> <li>\u2705 Extensions (x-* fields)</li> </ul>"},{"location":"compatibility/#openapi-31x","title":"OpenAPI 3.1.x","text":"<p>Full support for OpenAPI 3.1 additions:</p> <ul> <li>\u2705 Webhooks</li> <li>\u2705 JSON Schema 2020-12 compatibility</li> <li>\u2705 Nullable types via array syntax: <code>type: ['string', 'null']</code></li> <li>\u2705 <code>jsonSchemaDialect</code> field</li> <li>\u2705 Updated schema vocabulary</li> </ul>"},{"location":"compatibility/#known-limitations","title":"Known Limitations","text":"<p>Cicerone is designed to parse and represent OpenAPI schemas, not validate them. Here are some edge cases to be aware of:</p>"},{"location":"compatibility/#invalid-schemas","title":"Invalid Schemas","text":"<p>Cicerone will attempt to parse malformed schemas but may fail on:</p> <ul> <li>Malformed YAML/JSON: Syntax errors in the underlying format</li> <li>Invalid timestamps: Non-standard date/time values in the schema metadata</li> <li>Circular references: Some deeply nested circular <code>$ref</code> patterns may cause issues</li> </ul>"},{"location":"compatibility/#validation","title":"Validation","text":"<p>Cicerone parses schemas into Python objects but doesn't validate that they conform to the OpenAPI specification. If you need strict validation, use a dedicated OpenAPI validator before parsing with Cicerone.</p>"},{"location":"compatibility/#continuous-improvement","title":"Continuous Improvement","text":"<p>We're constantly improving compatibility:</p> <ul> <li>New schemas: As we discover edge cases, we add them to our test fixtures</li> <li>Bug fixes: GitHub Issues and PRs help us identify and fix compatibility problems</li> <li>Feature requests: We track OpenAPI specification updates and add support for new features</li> </ul> <p>If you encounter a schema that Cicerone can't parse, please open an issue with the schema or a link to it.</p>"},{"location":"compatibility/#see-also","title":"See Also","text":"<ul> <li>Parser API - Loading specifications from different sources</li> <li>Working with References - Resolving <code>$ref</code> references</li> <li>Models - Understanding the OpenAPI object models</li> </ul>"},{"location":"install/","title":"\ud83c\udfd7\ufe0f Install","text":""},{"location":"install/#with-pip","title":"With pip","text":"<pre><code>pip install cicerone\n</code></pre>"},{"location":"install/#with-uv","title":"With uv","text":"<pre><code>uv add cicerone\n</code></pre>"},{"location":"models/","title":"Spec Models","text":"<p>Cicerone provides Pydantic-based models for all OpenAPI 3.x specification objects. These models provide type-safe access to the OpenAPI schema and make it easy to explore and traverse specifications in a pythonic way.</p>"},{"location":"models/#overview","title":"Overview","text":"<p>All spec models are available in the <code>cicerone.spec</code> module:</p> <pre><code>from cicerone.spec import (\n    Callback,\n    Components,\n    Contact,\n    Encoding,\n    Example,\n    ExternalDocumentation,\n    Header,\n    Info,\n    License,\n    Link,\n    MediaType,\n    OAuthFlow,\n    OAuthFlows,\n    OpenAPISpec,\n    Operation,\n    Parameter,\n    PathItem,\n    Paths,\n    RequestBody,\n    Response,\n    Schema,\n    SecurityScheme,\n    Server,\n    ServerVariable,\n    Tag,\n    Version,\n    Webhooks,\n)\n</code></pre> <p>Though we recommend importing just the <code>spec</code> module to maintain sensible namespacing:</p> <pre><code>from cicerone import spec as cicerone_spec\n\ncicerone_spec.OpenAPISpec\n</code></pre>"},{"location":"models/#core-models","title":"Core Models","text":""},{"location":"models/#openapispec","title":"OpenAPISpec","text":"<p>The top-level model representing an entire OpenAPI specification.</p> <p>Key Attributes:</p> <ul> <li><code>version</code> (Version): OpenAPI version</li> <li><code>info</code> (Info): Metadata about the API</li> <li><code>paths</code> (Paths): Available paths and operations</li> <li><code>components</code> (Components): Reusable component definitions</li> <li><code>servers</code> (list[Server]): Server information</li> <li><code>security</code> (list[dict]): Global security requirements</li> <li><code>tags</code> (list[Tag]): Available tags for grouping operations</li> <li><code>webhooks</code> (Webhooks): Webhook definitions (OpenAPI 3.1+)</li> <li><code>external_docs</code> (ExternalDocumentation): External documentation</li> <li><code>raw</code> (dict): The original specification as a dictionary</li> </ul> <p>Key Methods:</p> <ul> <li><code>operation_by_operation_id(operation_id)</code>: Find an operation object by its operationId</li> <li><code>all_operations()</code>: Generator yielding all operation objects</li> <li><code>resolve_reference(ref)</code>: Resolve a $ref reference</li> <li><code>get_all_references()</code>: Get all references in the spec</li> </ul> <p>Example:</p> <pre><code>from cicerone import parse as cicerone_parse\n\nspec = cicerone_parse.parse_spec_from_file('openapi.yaml')\n\nprint(spec)  \n&gt;&gt;&gt; &lt;OpenAPISpec: 'My API' v3.0.0, 5 paths, 10 schemas&gt;\nprint(f\"API: {spec.info.title} v{spec.info.version}\")\n&gt;&gt;&gt; API: My API v3.0.0\nprint(f\"OpenAPI version: {spec.version}\")\n&gt;&gt;&gt; OpenAPI version 3.1.0\n\n# Find operation\nop = spec.operation_by_operation_id(\"createUser\")\nif op:\n    print(f\"Operation: {op.method.upper()} {op.path}\")\n&gt;&gt;&gt; Operation: POST /users\n\n# Iterate all operations\nfor operation in spec.all_operations():\n    print(f\"{operation.method.upper()} {operation.path} - {operation.summary}\")\n</code></pre>"},{"location":"models/#info","title":"Info","text":"<p>Metadata about the API.</p> <p>Key Attributes:</p> <ul> <li><code>title</code> (str): API title (required)</li> <li><code>version</code> (str): API version (required)</li> <li><code>description</code> (str | None): API description</li> <li><code>terms_of_service</code> (str | None): Terms of service URL</li> <li><code>contact</code> (Contact | None): Contact information</li> <li><code>license</code> (License | None): License information</li> <li><code>summary</code> (str | None): Short summary (OpenAPI 3.1+)</li> </ul> <p>Example:</p> <pre><code>print(f\"{spec.info.title} v{spec.info.version}\")\nif spec.info.description:\n    print(spec.info.description)\nif spec.info.contact:\n    print(f\"Contact: {spec.info.contact.email}\")\n</code></pre>"},{"location":"models/#schema","title":"Schema","text":"<p>Represents a JSON Schema / OpenAPI Schema object. This is one of the most commonly used models for exploring data structures.</p> <p>Key Attributes:</p> <ul> <li><code>type</code> (str | None): Schema type (object, array, string, number, integer, boolean, null)</li> <li><code>title</code> (str | None): Schema title</li> <li><code>description</code> (str | None): Schema description</li> <li><code>properties</code> (dict[str, Schema]): Object properties (for type=object)</li> <li><code>required</code> (list[str]): Required property names</li> <li><code>items</code> (Schema | None): Array item schema (for type=array)</li> <li><code>all_of</code> (list[Schema] | None): allOf composition</li> <li><code>one_of</code> (list[Schema] | None): oneOf composition</li> <li><code>any_of</code> (list[Schema] | None): anyOf composition</li> <li><code>not_</code> (Schema | None): not composition</li> </ul> <p>Note: Schema models allow extra fields to support the full JSON Schema vocabulary (format, enum, minimum, maximum, pattern, etc.)</p> <p>Example:</p> <pre><code># Get a schema from components\nuser_schema = spec.components.schemas.get(\"User\")\n\nprint(user_schema)  # &lt;Schema: type=object, 5 properties, required=['id', 'username']&gt;\nprint(f\"Type: {user_schema.type}\")\nprint(f\"Required: {user_schema.required}\")\n\n# Explore properties\nfor prop_name, prop_schema in user_schema.properties.items():\n    print(f\"  {prop_name}: {prop_schema.type}\")\n    if prop_name in user_schema.required:\n        print(f\"    (required)\")\n\n# Access additional JSON Schema fields\nif hasattr(user_schema, 'format'):\n    print(f\"Format: {user_schema.format}\")\n</code></pre>"},{"location":"models/#components","title":"Components","text":"<p>Container for reusable component definitions.</p> <p>Key Attributes:</p> <ul> <li><code>schemas</code> (dict[str, Schema]): Reusable schemas</li> <li><code>responses</code> (dict[str, Response]): Reusable responses</li> <li><code>parameters</code> (dict[str, Parameter]): Reusable parameters</li> <li><code>examples</code> (dict[str, Example]): Reusable examples</li> <li><code>request_bodies</code> (dict[str, RequestBody]): Reusable request bodies</li> <li><code>headers</code> (dict[str, Header]): Reusable headers</li> <li><code>security_schemes</code> (dict[str, SecurityScheme]): Security scheme definitions</li> <li><code>links</code> (dict[str, Link]): Reusable links</li> <li><code>callbacks</code> (dict[str, Callback]): Reusable callbacks</li> </ul> <p>Key Methods:</p> <ul> <li><code>get_schema(schema_name)</code>: Get a schema by name</li> </ul> <p>Example:</p> <pre><code># List all schemas\nprint(f\"Schemas: {list(spec.components.schemas.keys())}\")\n\n# Get a specific schema\nuser = spec.components.get_schema(\"User\")\nif user:\n    print(f\"User properties: {list(user.properties.keys())}\")\n\n# List security schemes\nfor name, scheme in spec.components.security_schemes.items():\n    print(f\"{name}: {scheme.type}\")\n</code></pre>"},{"location":"models/#path-and-operation-models","title":"Path and Operation Models","text":""},{"location":"models/#paths","title":"Paths","text":"<p>Container for all API paths.</p> <p>Key Attributes:</p> <ul> <li><code>items</code> (dict[str, PathItem]): Mapping of path strings to PathItem objects</li> </ul> <p>Key Methods:</p> <ul> <li><code>all_operations()</code>: Generator yielding all operations across all paths</li> </ul> <p>Example:</p> <pre><code>print(spec.paths)  # &lt;Paths: 5 paths, 12 operations [/users, /users/{id}, ...]&gt;\n\n# Iterate paths\nfor path_str, path_item in spec.paths.items.items():\n    print(f\"Path: {path_str}\")\n\n# Get all operations\nfor operation in spec.paths.all_operations():\n    print(f\"{operation.method.upper()} {operation.path}\")\n</code></pre>"},{"location":"models/#pathitem","title":"PathItem","text":"<p>Represents a single path and its operations.</p> <p>Key Attributes:</p> <ul> <li><code>path</code> (str): The path string (e.g., \"/users/{id}\")</li> <li><code>summary</code> (str | None): Path summary</li> <li><code>description</code> (str | None): Path description</li> <li><code>get</code>, <code>post</code>, <code>put</code>, <code>delete</code>, <code>patch</code>, <code>head</code>, <code>options</code>, <code>trace</code> (Operation | None): HTTP method operations</li> <li><code>parameters</code> (list[Parameter]): Parameters applicable to all operations in this path</li> <li><code>servers</code> (list[Server]): Server overrides for this path</li> </ul> <p>Example:</p> <pre><code>users_path = spec.paths.items[\"/users\"]\nprint(users_path)  # &lt;PathItem: /users [GET, POST]&gt;\n\nif users_path.get:\n    print(f\"GET: {users_path.get.summary}\")\nif users_path.post:\n    print(f\"POST: {users_path.post.summary}\")\n</code></pre>"},{"location":"models/#operation","title":"Operation","text":"<p>Represents a single API operation (HTTP method on a path).</p> <p>Key Attributes:</p> <ul> <li><code>method</code> (str): HTTP method (get, post, put, delete, etc.)</li> <li><code>path</code> (str): The path this operation belongs to</li> <li><code>operation_id</code> (str | None): Unique operation identifier</li> <li><code>summary</code> (str | None): Short summary</li> <li><code>description</code> (str | None): Detailed description</li> <li><code>tags</code> (list[str]): Tags for grouping</li> <li><code>parameters</code> (list[Parameter]): Operation parameters</li> <li><code>request_body</code> (RequestBody | None): Request body definition</li> <li><code>responses</code> (dict[str, Response]): Response definitions by status code</li> <li><code>callbacks</code> (dict[str, Callback]): Callback definitions</li> <li><code>security</code> (list[dict]): Security requirements</li> <li><code>deprecated</code> (bool): Whether the operation is deprecated</li> </ul> <p>Example:</p> <pre><code>op = spec.operation_by_operation_id(\"createUser\")\n\nprint(op)  # &lt;Operation: POST /users, id=createUser, 'Create a new user', tags=['users']&gt;\nprint(f\"Method: {op.method.upper()}\")\nprint(f\"Path: {op.path}\")\nprint(f\"Summary: {op.summary}\")\nprint(f\"Tags: {op.tags}\")\n\n# Check parameters\nfor param in op.parameters:\n    print(f\"Parameter: {param.name} ({param.in_})\")\n\n# Check request body\nif op.request_body:\n    print(f\"Request body required: {op.request_body.required}\")\n\n# Check responses\nfor status_code, response in op.responses.items():\n    print(f\"Response {status_code}: {response.description}\")\n</code></pre>"},{"location":"models/#parameter","title":"Parameter","text":"<p>Represents a parameter (query, path, header, or cookie).</p> <p>Key Attributes:</p> <ul> <li><code>name</code> (str): Parameter name</li> <li><code>in_</code> (str): Parameter location (query, path, header, cookie)</li> <li><code>description</code> (str | None): Parameter description</li> <li><code>required</code> (bool): Whether required</li> <li><code>deprecated</code> (bool): Whether deprecated</li> <li><code>schema</code> (Schema | None): Parameter schema</li> <li><code>style</code> (str | None): Serialization style</li> <li><code>explode</code> (bool | None): Explode option</li> <li><code>example</code> (Any): Example value</li> <li><code>examples</code> (dict[str, Example]): Multiple examples</li> </ul> <p>Example:</p> <pre><code>for param in operation.parameters:\n    req_str = \"required\" if param.required else \"optional\"\n    print(f\"{param.name} ({param.in_}): {req_str}\")\n    if param.schema:\n        print(f\"  Type: {param.schema.type}\")\n</code></pre>"},{"location":"models/#response","title":"Response","text":"<p>Represents an operation response.</p> <p>Key Attributes:</p> <ul> <li><code>description</code> (str): Response description (required)</li> <li><code>headers</code> (dict[str, Header]): Response headers</li> <li><code>content</code> (dict[str, MediaType]): Response content by media type</li> <li><code>links</code> (dict[str, Link]): Response links</li> </ul> <p>Example:</p> <pre><code>success_response = operation.responses.get(\"200\")\nif success_response:\n    print(f\"Description: {success_response.description}\")\n\n    # Check content types\n    for media_type, content in success_response.content.items():\n        print(f\"Media type: {media_type}\")\n        if content.schema:\n            print(f\"  Schema: {content.schema.type}\")\n</code></pre>"},{"location":"models/#requestbody","title":"RequestBody","text":"<p>Represents a request body definition.</p> <p>Key Attributes:</p> <ul> <li><code>description</code> (str | None): Request body description</li> <li><code>content</code> (dict[str, MediaType]): Content by media type</li> <li><code>required</code> (bool): Whether required</li> </ul> <p>Example:</p> <pre><code>if operation.request_body:\n    print(f\"Required: {operation.request_body.required}\")\n\n    for media_type, content in operation.request_body.content.items():\n        print(f\"Content type: {media_type}\")\n        if content.schema:\n            print(f\"  Schema: {content.schema}\")\n</code></pre>"},{"location":"models/#server-models","title":"Server Models","text":""},{"location":"models/#server","title":"Server","text":"<p>Represents a server definition.</p> <p>Key Attributes:</p> <ul> <li><code>url</code> (str): Server URL</li> <li><code>description</code> (str | None): Server description</li> <li><code>variables</code> (dict[str, ServerVariable]): Server variables for URL templating</li> </ul> <p>Example:</p> <pre><code>for server in spec.servers:\n    print(f\"Server: {server.url}\")\n    if server.description:\n        print(f\"  {server.description}\")\n\n    for var_name, var in server.variables.items():\n        print(f\"  Variable {var_name}: default={var.default}\")\n</code></pre>"},{"location":"models/#servervariable","title":"ServerVariable","text":"<p>Represents a server URL template variable.</p> <p>Key Attributes:</p> <ul> <li><code>enum</code> (list[str] | None): Allowed values</li> <li><code>default</code> (str): Default value</li> <li><code>description</code> (str | None): Variable description</li> </ul>"},{"location":"models/#security-models","title":"Security Models","text":""},{"location":"models/#securityscheme","title":"SecurityScheme","text":"<p>Represents a security scheme definition.</p> <p>Key Attributes:</p> <ul> <li><code>type</code> (str): Security type (apiKey, http, oauth2, openIdConnect, mutualTLS)</li> <li><code>description</code> (str | None): Security scheme description</li> <li><code>name</code> (str | None): Parameter name (for apiKey)</li> <li><code>in_</code> (str | None): Parameter location (for apiKey)</li> <li><code>scheme</code> (str | None): HTTP authorization scheme (for http)</li> <li><code>bearer_format</code> (str | None): Bearer token format (for http bearer)</li> <li><code>flows</code> (OAuthFlows | None): OAuth flow definitions (for oauth2)</li> <li><code>open_id_connect_url</code> (str | None): OpenID Connect URL (for openIdConnect)</li> </ul> <p>Example:</p> <pre><code>for name, scheme in spec.components.security_schemes.items():\n    print(f\"{name}: {scheme.type}\")\n\n    if scheme.type == \"http\":\n        print(f\"  Scheme: {scheme.scheme}\")\n    elif scheme.type == \"apiKey\":\n        print(f\"  In: {scheme.in_}, Name: {scheme.name}\")\n    elif scheme.type == \"oauth2\" and scheme.flows:\n        if scheme.flows.authorization_code:\n            print(f\"  Auth URL: {scheme.flows.authorization_code.authorization_url}\")\n</code></pre>"},{"location":"models/#content-models","title":"Content Models","text":""},{"location":"models/#mediatype","title":"MediaType","text":"<p>Represents content for a specific media type.</p> <p>Key Attributes:</p> <ul> <li><code>schema</code> (Schema | None): Content schema</li> <li><code>example</code> (Any): Example value</li> <li><code>examples</code> (dict[str, Example]): Multiple examples</li> <li><code>encoding</code> (dict[str, Encoding]): Encoding information</li> </ul> <p>Example:</p> <pre><code>content = response.content.get(\"application/json\")\nif content and content.schema:\n    print(f\"Schema: {content.schema.type}\")\n</code></pre>"},{"location":"models/#example","title":"Example","text":"<p>Represents an example value.</p> <p>Key Attributes:</p> <ul> <li><code>summary</code> (str | None): Example summary</li> <li><code>description</code> (str | None): Example description</li> <li><code>value</code> (Any): The example value</li> <li><code>external_value</code> (str | None): URL to external example</li> </ul>"},{"location":"models/#other-models","title":"Other Models","text":""},{"location":"models/#tag","title":"Tag","text":"<p>Represents a tag for grouping operations.</p> <p>Key Attributes:</p> <ul> <li><code>name</code> (str): Tag name</li> <li><code>description</code> (str | None): Tag description</li> <li><code>external_docs</code> (ExternalDocumentation | None): External documentation</li> </ul> <p>Example:</p> <pre><code>for tag in spec.tags:\n    print(f\"Tag: {tag.name}\")\n    if tag.description:\n        print(f\"  {tag.description}\")\n</code></pre>"},{"location":"models/#callback","title":"Callback","text":"<p>Represents a callback definition.</p> <p>Key Attributes:</p> <ul> <li><code>expressions</code> (dict[str, PathItem]): Callback expressions</li> </ul> <p>Example:</p> <pre><code>for name, callback in spec.components.callbacks.items():\n    print(f\"Callback: {name}\")\n    for expr, path_item in callback.expressions.items():\n        print(f\"  Expression: {expr}\")\n</code></pre>"},{"location":"models/#webhooks","title":"Webhooks","text":"<p>Container for webhook definitions (OpenAPI 3.1+).</p> <p>Key Attributes:</p> <ul> <li><code>items</code> (dict[str, PathItem]): Webhook definitions</li> </ul> <p>Key Methods:</p> <ul> <li><code>all_operations()</code>: Generator yielding all webhook operations</li> </ul> <p>Example:</p> <pre><code>for webhook_name, path_item in spec.webhooks.items.items():\n    print(f\"Webhook: {webhook_name}\")\n    for operation in path_item.all_operations():\n        print(f\"  {operation.method.upper()}: {operation.summary}\")\n</code></pre>"},{"location":"models/#version","title":"Version","text":"<p>Represents an OpenAPI version.</p> <p>Key Attributes:</p> <ul> <li><code>major</code> (int): Major version number</li> <li><code>minor</code> (int): Minor version number</li> <li><code>patch</code> (int): Patch version number</li> </ul> <p>Example:</p> <pre><code>print(f\"OpenAPI {spec.version.major}.{spec.version.minor}.{spec.version.patch}\")\n\nif spec.version.major == 3 and spec.version.minor &gt;= 1:\n    print(\"OpenAPI 3.1+ features available\")\n</code></pre>"},{"location":"models/#model-features","title":"Model Features","text":""},{"location":"models/#string-representations","title":"String Representations","text":"<p>All models provide helpful string representations:</p> <pre><code>print(spec)\n# &lt;OpenAPISpec: 'My API' v3.0.0, 5 paths, 10 schemas&gt;\n\nprint(spec.paths)\n# &lt;Paths: 5 paths, 12 operations [/users, /users/{id}, ...]&gt;\n\nprint(spec.components)\n# &lt;Components: 10 schemas, 5 responses, 3 parameters&gt;\n\noperation = spec.operation_by_operation_id(\"listUsers\")\nprint(operation)\n# &lt;Operation: GET /users, id=listUsers, 'List all users', tags=['users']&gt;\n</code></pre>"},{"location":"models/#extra-fields","title":"Extra Fields","text":"<p>All models use Pydantic's <code>extra=\"allow\"</code> configuration to preserve:</p> <ul> <li>Vendor extensions (x-* fields)</li> <li>Future OpenAPI additions</li> </ul> <p>Example:</p> <pre><code># Access vendor extensions\nif hasattr(spec.info, 'x_custom_field'):\n    print(f\"Custom: {spec.info.x_custom_field}\")\n\n# Access via raw dict\ncustom_value = spec.raw.get('x-api-id')\n</code></pre>"},{"location":"models/#type-safety","title":"Type Safety","text":"<p>All models are fully typed using Pydantic, providing:</p> <ul> <li>Runtime validation</li> <li>IDE autocomplete</li> <li>Type checking with mypy/pyright/ty</li> </ul> <pre><code>from cicerone.spec import Schema\n\n# Type hints work\nschema: Schema = spec.components.schemas[\"User\"]\n\n# IDE knows what properties are available\nprint(schema.type)  # \u2713 IDE autocomplete\nprint(schema.properties)  # \u2713 IDE autocomplete\n</code></pre>"},{"location":"models/#see-also","title":"See Also","text":"<ul> <li>Parser API - Loading specifications</li> <li>Working with References - Resolving $ref references</li> <li>OpenAPI Specification - Official spec</li> </ul>"},{"location":"parser/","title":"Parser API","text":"<p>The parser module provides functions for loading OpenAPI specifications from various sources. </p> <p>All parsing functions return an <code>OpenAPISpec</code> object that you can use to explore and traverse the schema.</p>"},{"location":"parser/#overview","title":"Overview","text":"<p>Cicerone supports loading OpenAPI specifications from:</p> <ul> <li>Files (YAML or JSON, auto-detected)</li> <li>URLs (with content-type detection)</li> <li>Dictionaries (Python dict objects)</li> <li>JSON strings</li> <li>YAML strings</li> </ul> <p>All parser functions are available in the <code>cicerone.parse</code> module:</p> <pre><code>from cicerone import parse as cicerone_parse\n</code></pre>"},{"location":"parser/#parsing-functions","title":"Parsing Functions","text":""},{"location":"parser/#parse_spec_from_filepath","title":"<code>parse_spec_from_file(path)</code>","text":"<p>Load an OpenAPI specification from a file. The format (JSON or YAML) is auto-detected based on the file extension.</p> <p>Parameters:</p> <ul> <li><code>path</code> (str | pathlib.Path): Path to the OpenAPI specification file</li> </ul> <p>Returns:</p> <ul> <li><code>OpenAPISpec</code>: Parsed specification object</li> </ul> <p>Format Detection:</p> <ul> <li>Files with <code>.yaml</code> or <code>.yml</code> extension are parsed as YAML</li> <li>Other files are tried as JSON first, with YAML as fallback</li> </ul> <p>Example:</p> <pre><code>from cicerone import parse as cicerone_parse\n\n# Load from YAML file\nspec = cicerone_parse.parse_spec_from_file(\"openapi.yaml\")\n\n# Load from JSON file\nspec = cicerone_parse.parse_spec_from_file(\"openapi.json\")\n\n# Works with pathlib.Path too\nfrom pathlib import Path\nspec = cicerone_parse.parse_spec_from_file(Path(\"specs/api.yaml\"))\n</code></pre>"},{"location":"parser/#parse_spec_from_urlurl","title":"<code>parse_spec_from_url(url)</code>","text":"<p>Load an OpenAPI specification from a URL. The format is detected from the Content-Type header.</p> <p>Parameters:</p> <ul> <li><code>url</code> (str): URL to fetch the OpenAPI specification from</li> </ul> <p>Returns:</p> <ul> <li><code>OpenAPISpec</code>: Parsed specification object</li> </ul> <p>Format Detection:</p> <ul> <li>URLs returning <code>application/yaml</code> or similar are parsed as YAML</li> <li>Other content types are tried as JSON first, with YAML as fallback</li> </ul> <p>Example:</p> <pre><code>from cicerone import parse as cicerone_parse\n\n# Load from URL\nspec = cicerone_parse.parse_spec_from_url(\"https://api.example.com/openapi.json\")\n\n# Works with YAML URLs too\nspec = cicerone_parse.parse_spec_from_url(\"https://raw.githubusercontent.com/example/api/openapi.yaml\")\n</code></pre>"},{"location":"parser/#parse_spec_from_dictdata","title":"<code>parse_spec_from_dict(data)</code>","text":"<p>Create an OpenAPI specification from a Python dictionary.</p> <p>Parameters:</p> <ul> <li><code>data</code> (Mapping[str, Any]): The OpenAPI specification as a dictionary</li> </ul> <p>Returns:</p> <ul> <li><code>OpenAPISpec</code>: Parsed specification object</li> </ul> <p>Example:</p> <pre><code>from cicerone import parse as cicerone_parse\n\n# From a dictionary\nspec_data = {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n        \"title\": \"My API\",\n        \"version\": \"1.0.0\"\n    },\n    \"paths\": {\n        \"/users\": {\n            \"get\": {\n                \"summary\": \"List users\",\n                \"operationId\": \"listUsers\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Success\"\n                    }\n                }\n            }\n        }\n    }\n}\n\nspec = cicerone_parse.parse_spec_from_dict(spec_data)\nprint(spec.info.title)  # \"My API\"\n</code></pre>"},{"location":"parser/#parse_spec_from_jsontext","title":"<code>parse_spec_from_json(text)</code>","text":"<p>Parse an OpenAPI specification from a JSON string.</p> <p>Parameters:</p> <ul> <li><code>text</code> (str): JSON string containing the OpenAPI specification</li> </ul> <p>Returns:</p> <ul> <li><code>OpenAPISpec</code>: Parsed specification object</li> </ul> <p>Example:</p> <pre><code>from cicerone import parse as cicerone_parse\n\njson_str = '''\n{\n    \"openapi\": \"3.0.0\",\n    \"info\": {\n        \"title\": \"My API\",\n        \"version\": \"1.0.0\"\n    },\n    \"paths\": {}\n}\n'''\n\nspec = cicerone_parse.parse_spec_from_json(json_str)\n</code></pre>"},{"location":"parser/#parse_spec_from_yamltext","title":"<code>parse_spec_from_yaml(text)</code>","text":"<p>Parse an OpenAPI specification from a YAML string.</p> <p>Parameters:</p> <ul> <li><code>text</code> (str): YAML string containing the OpenAPI specification</li> </ul> <p>Returns:</p> <ul> <li><code>OpenAPISpec</code>: Parsed specification object</li> </ul> <p>Example:</p> <pre><code>from cicerone import parse as cicerone_parse\n\nyaml_str = '''\nopenapi: \"3.0.0\"\ninfo:\n  title: My API\n  version: 1.0.0\npaths:\n  /users:\n    get:\n      summary: List users\n      operationId: listUsers\n'''\n\nspec = cicerone_parse.parse_spec_from_yaml(yaml_str)\n</code></pre>"},{"location":"parser/#working-with-parsed-specs","title":"Working with Parsed Specs","text":"<p>Once you've parsed a specification, you can explore it using the <code>OpenAPISpec</code> object.</p> <p>See models for more information.</p>"},{"location":"parser/#error-handling","title":"Error Handling","text":"<p>All parser functions may raise exceptions for invalid input:</p> <pre><code>from cicerone import parse as cicerone_parse\nimport json\n\ntry:\n    spec = cicerone_parse.parse_spec_from_file(\"invalid.yaml\")\nexcept FileNotFoundError:\n    print(\"File not found\")\nexcept yaml.YAMLError as e:\n    print(f\"Invalid YAML: {e}\")\nexcept json.JSONDecodeError as e:\n    print(f\"Invalid JSON: {e}\")\n</code></pre>"},{"location":"parser/#openapi-version-support","title":"OpenAPI Version Support","text":"<p>Cicerone supports OpenAPI 3.0.x and 3.1.x specifications:</p> <ul> <li>OpenAPI 3.0.x: Full support for all features</li> <li>OpenAPI 3.1.x: Full support including webhooks and JSON Schema extensions</li> </ul> <p>The parser automatically detects the OpenAPI version from the <code>openapi</code> field in the specification.</p>"},{"location":"parser/#performance-considerations","title":"Performance Considerations","text":"<p>The parser is designed for performance. Even for large specifications (1000+ paths), parsing typically takes less than 100ms.</p>"},{"location":"parser/#see-also","title":"See Also","text":"<ul> <li>Working with References - Resolving $ref references</li> <li>Spec Models - Understanding the OpenAPI object models</li> </ul>"},{"location":"references/","title":"Working with References","text":"<p>OpenAPI specifications use references (<code>$ref</code>) to avoid duplication and keep schemas manageable. Cicerone provides a comprehensive API for navigating and resolving these references.</p>"},{"location":"references/#understanding-references-in-openapi","title":"Understanding References in OpenAPI","text":"<p>A reference in OpenAPI uses the <code>$ref</code> keyword to point to another part of the specification. References follow the JSON Reference specification (RFC 6901) and use JSON Pointer syntax.</p>"},{"location":"references/#reference-locations","title":"Reference Locations","text":"<p>References can appear in various places in an OpenAPI specification:</p> <ul> <li>Schema objects - Most common, referencing reusable schemas</li> <li>Response objects - Referencing reusable responses</li> <li>Parameter objects - Referencing reusable parameters</li> <li>Request body objects - Referencing reusable request bodies</li> <li>And more - Anywhere the spec allows a Reference Object</li> </ul>"},{"location":"references/#basic-reference-navigation","title":"Basic Reference Navigation","text":""},{"location":"references/#resolving-a-reference","title":"Resolving a Reference","text":"<p>The most common operation is resolving a reference to get its target object as a typed Pydantic model:</p> <pre><code>from cicerone import parse as cicerone_parse\nfrom cicerone.spec import Schema\n\n# Load your OpenAPI spec\nspec = cicerone_parse.parse_spec_from_file('openapi.yaml')\n\n# Resolve a reference to a schema - returns a Schema object, not a dict\nuser_schema = spec.resolve_reference('#/components/schemas/User')\nprint(f\"Type: {type(user_schema)}\")  # &lt;class 'cicerone.spec.schema.Schema'&gt;\nprint(f\"User schema type: {user_schema.type}\")\nprint(f\"User properties: {list(user_schema.properties.keys())}\")\n</code></pre> <p>Example with a sample schema:</p> <pre><code>components:\n  schemas:\n    User:\n      type: object\n      required:\n        - id\n        - username\n        - email\n      properties:\n        id:\n          type: string\n        username:\n          type: string\n        email:\n          type: string\n          format: email\n</code></pre> <pre><code># Resolves to a typed Schema object\nuser_schema = spec.resolve_reference('#/components/schemas/User')\nassert isinstance(user_schema, Schema)\n# Access properties directly as attributes\nprint(user_schema.type)  # 'object'\nprint(user_schema.required)  # ['id', 'username', 'email']\nprint(user_schema.properties['email'].format)  # 'email'\n</code></pre>"},{"location":"references/#finding-all-references","title":"Finding All References","text":"<p>You can discover all references in your specification as a dictionary:</p> <pre><code># Get all references as a dict mapping $ref strings to Reference objects\nall_refs = spec.get_all_references()\n\n# Access specific references by their $ref string\nuser_ref = all_refs.get('#/components/schemas/User')\nif user_ref:\n    print(f\"Found reference: {user_ref.ref}\")\n\n# Filter by type\nlocal_refs = {k: v for k, v in all_refs.items() if v.is_local}\nexternal_refs = {k: v for k, v in all_refs.items() if v.is_external}\n\nprint(f\"Found {len(all_refs)} total references\")\nprint(f\"Local: {len(local_refs)}, External: {len(external_refs)}\")\n\n# List all schema references\nschema_refs = {k: v for k, v in all_refs.items() if '/schemas/' in k}\nfor ref_str, ref_obj in schema_refs.items():\n    print(f\"  - {ref_str}\")\n</code></pre>"},{"location":"references/#working-with-the-reference-model","title":"Working with the Reference Model","text":"<p>The <code>Reference</code> class provides properties to inspect and work with reference objects:</p> <pre><code>from cicerone.references import Reference\nfrom cicerone.spec import Schema\n\n# Create a reference object\nref = Reference(ref='#/components/schemas/Pet')\n\n# Check reference type\nprint(f\"Is local: {ref.is_local}\")  # True\nprint(f\"Is external: {ref.is_external}\")  # False\n\n# Get the JSON Pointer\nprint(f\"Pointer: {ref.pointer}\")  # /components/schemas/Pet\n\n# Get pointer components\nprint(f\"Parts: {ref.pointer_parts}\")  # ['components', 'schemas', 'Pet']\n\n# Resolve the reference to get the actual Schema object\npet_schema = spec.resolve_reference(ref)\nassert isinstance(pet_schema, Schema)\nprint(f\"Pet schema type: {pet_schema.type}\")\n</code></pre>"},{"location":"references/#oas-31-summary-and-description","title":"OAS 3.1 Summary and Description","text":"<p>In OpenAPI 3.1, Reference Objects can have <code>summary</code> and <code>description</code> fields:</p> <pre><code>from cicerone.references import Reference\n\nref = Reference(ref='#/components/schemas/User',\n    summary='User schema',\n    description='Represents a user in the system'\n)\n\nprint(f\"Reference: {ref.ref}\")\nprint(f\"Summary: {ref.summary}\")\nprint(f\"Description: {ref.description}\")\n</code></pre>"},{"location":"references/#advanced-reference-operations","title":"Advanced Reference Operations","text":""},{"location":"references/#nested-references","title":"Nested References","text":"<p>Cicerone can automatically follow nested references:</p> <pre><code>components:\n  schemas:\n    UserList:\n      type: array\n      items:\n        $ref: '#/components/schemas/User'\n    User:\n      $ref: '#/components/schemas/Person'\n    Person:\n      type: object\n      properties:\n        name:\n          type: string\n</code></pre> <pre><code># By default, follows nested references\nperson = spec.resolve_reference('#/components/schemas/User')\n# Returns the Person schema (fully resolved)\n\n# Or stop at the first level\nuser_ref = spec.resolve_reference('#/components/schemas/User', follow_nested=False)\n</code></pre>"},{"location":"references/#circular-reference-detection","title":"Circular Reference Detection","text":"<p>Some schemas have circular references (e.g., tree structures):</p> <pre><code>components:\n  schemas:\n    Node:\n      type: object\n      properties:\n        value:\n          type: string\n        children:\n          type: array\n          items:\n            $ref: '#/components/schemas/Node'  # Circular!\n</code></pre> <p>Cicerone detects and handles circular references:</p> <pre><code>from cicerone.references import ReferenceResolver\n\n# Check if a reference is circular\nresolver = ReferenceResolver(spec)\nis_circular = resolver.is_circular_reference('#/components/schemas/Node')\nprint(f\"Is circular: {is_circular}\")\n\n# When resolving with follow_nested=True, circular references are handled\n# by stopping recursion - the circular reference remains as a Reference object\n# pointing back to create a linked-list style structure\nnode = spec.resolve_reference('#/components/schemas/Node', follow_nested=True)\nprint(\"Node schema resolved successfully with circular handling\")\n</code></pre>"},{"location":"references/#reference-resolution-rules","title":"Reference Resolution Rules","text":""},{"location":"references/#oas-30-vs-31-differences","title":"OAS 3.0 vs 3.1 Differences","text":"<p>The behavior of references differs slightly between OpenAPI versions:</p> <p>OpenAPI 3.0:</p> <ul> <li>Reference Objects can only contain <code>$ref</code></li> <li>Adjacent keywords are ignored</li> <li>References fully replace the object</li> </ul> <p>OpenAPI 3.1:</p> <ul> <li>Reference Objects can have <code>summary</code> and <code>description</code></li> <li>These fields override the target's values</li> <li>In Schema Objects, <code>$ref</code> can coexist with other keywords (acts like <code>allOf</code>)</li> </ul> <p>Cicerone handles both versions correctly, preserving the raw specification data.</p>"},{"location":"references/#api-reference","title":"API Reference","text":""},{"location":"references/#openapispec-methods","title":"OpenAPISpec Methods","text":""},{"location":"references/#resolve_referenceref-follow_nestedtrue","title":"<code>resolve_reference(ref, follow_nested=True)</code>","text":"<p>Resolve a reference to its target object as a typed Pydantic model.</p> <p>Parameters:</p> <ul> <li><code>ref</code> (str or Reference): Reference to resolve</li> <li><code>follow_nested</code> (bool): Whether to recursively resolve nested references</li> </ul> <p>Returns: Typed Pydantic model (Schema, Response, Parameter, etc.) when the reference points to a recognized component type. Otherwise returns raw data.</p> <p>Raises:</p> <ul> <li><code>ValueError</code>: If reference cannot be resolved</li> <li><code>RecursionError</code>: If circular reference detected</li> </ul>"},{"location":"references/#get_all_references","title":"<code>get_all_references()</code>","text":"<p>Get all references in the specification.</p> <p>Returns: Dictionary mapping $ref strings to Reference objects</p> <p>Example:</p> <pre><code>all_refs = spec.get_all_references()\nuser_ref = all_refs.get('#/components/schemas/User')\nlocal_refs = {k: v for k, v in all_refs.items() if v.is_local}\n</code></pre>"},{"location":"references/#is_circular_referenceref","title":"<code>is_circular_reference(ref)</code>","text":"<p>Check if a reference creates a circular dependency.</p> <p>Parameters:</p> <ul> <li><code>ref</code> (str or Reference): Reference to check</li> </ul> <p>Returns: bool - True if circular</p>"},{"location":"references/#reference-class","title":"Reference Class","text":""},{"location":"references/#properties","title":"Properties","text":"<ul> <li><code>ref</code> (str): The reference string</li> <li><code>summary</code> (str | None): Summary (OAS 3.1+)</li> <li><code>description</code> (str | None): Description (OAS 3.1+)</li> <li><code>is_local</code> (bool): True if local reference (#...)</li> <li><code>is_external</code> (bool): True if external reference</li> <li><code>pointer</code> (str): JSON Pointer part (/components/schemas/User)</li> <li><code>document</code> (str): Document part (for external refs)</li> <li><code>pointer_parts</code> (list[str]): Pointer split into components</li> </ul>"},{"location":"references/#methods","title":"Methods","text":"<ul> <li><code>from_dict(data)</code>: Create from dictionary</li> <li><code>is_reference(data)</code>: Check if data contains $ref</li> </ul>"},{"location":"references/#best-practices","title":"Best Practices","text":"<ol> <li>Check for references before accessing: Use <code>Reference.is_reference()</code> to check if an object is a reference</li> <li>Handle circular references gracefully: Use <code>is_circular_reference()</code> before full resolution</li> <li>Cache resolved references: If resolving the same reference multiple times, cache the results</li> <li>Validate references: Check that all references in your spec can be resolved</li> </ol>"},{"location":"references/#limitations","title":"Limitations","text":"<p>Current limitations (to be addressed in future versions):</p> <ul> <li>External references (file paths, URLs) are not yet supported</li> <li><code>operationRef</code> in Link Objects is not yet implemented</li> <li><code>mapping</code> in Discriminator Objects is not yet implemented</li> <li>Dynamic references (<code>$dynamicRef</code>) from JSON Schema 2020-12 / OAS 3.1 are not yet supported</li> </ul>"},{"location":"references/#see-also","title":"See Also","text":"<ul> <li>OpenAPI Reference Object Specification</li> <li>JSON Pointer RFC 6901</li> <li>JSON Reference Draft</li> </ul>"}]}